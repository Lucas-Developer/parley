'''
This is now just a shim for testing until we get node-webkit working.
'''

import pbkdf2
import base64, hmac, hashlib
from urllib import urlencode, quote_plus
import os, platform, subprocess, shutil
import time
import json

def PYgetEncryptedKeyring():
  public_keys = [key['keyid'] for key in gpg.list_keys()]
  private_keys = [key['keyid'] for key in gpg.list_keys(True)]
  keyring = dict(public=gpg.export_keys(public_keys),private=gpg.export_keys(private_keys,True))
  encrypted_keyring = gpg.encrypt(json.dumps(keyring),None,passphrase=window.Parley.currentUser.attributes.passwords.local,symmetric=True,armor=False)
  return base64.b64encode(encrypted_keyring.data)

window.PYgetEncryptedKeyring = PYgetEncryptedKeyring


def PYclearKeys():
  secret_fps = [key['fingerprint'] for key in gpg.list_keys(True)]
  fps = [key['fingerprint'] for key in gpg.list_keys()]
  for fp in secret_fps:
    gpg.delete_keys(fp, True)
  for fp in fps:
    gpg.delete_keys(fp)

window.PYclearKeys = PYclearKeys


def PYimportEncryptedKeyring(b64_keyring):
  PYclearKeys()
  encrypted_keyring = base64.b64decode(b64_keyring)
  #try legacy method, then new method (old aes module didn't use OpenPGP format)
  #TODO: eventually remove legacy AES module
  try:
    keyring = json.loads(aes.decryptData(window.Parley.currentUser.attributes.passwords.local[0:32],encrypted_keyring))
  except:
    decrypt = gpg.decrypt(encrypted_keyring,passphrase=window.Parley.currentUser.attributes.passwords.local)
    keyring = json.loads(decrypt.data)
  gpg.import_keys(keyring['private'])
  gpg.import_keys(keyring['public'])
  return True

window.PYimportEncryptedKeyring = PYimportEncryptedKeyring


def PYgetPublicKey():
  #assume that there is a single private key per user, and use that to
  #get the keyid for the pair
  private_key = gpg.list_keys(True)
  keyid = private_key[0]['keyid']
  public_key = gpg.export_keys(keyid)
  return public_key

window.PYgetPublicKey = PYgetPublicKey


def PYsignAPIRequest(url, method, data):
  keys = window.Object.keys(data)
  keys.sort()
  values = [getattr(data,key) for key in keys]
  url_string = urlencode(zip(keys,values))
  sig = hmac.new(
      key=window.Parley.currentUser.attributes.passwords.remote,
      msg=method+'|'+url+'?'+url_string,
      digestmod=hashlib.sha256).digest()
  sig = base64.b64encode(sig,'-_').strip('=')
  return sig

window.PYsignAPIRequest = PYsignAPIRequest


def PYpbkdf2(data):
  salt = window.Parley.currentUser.attributes.email + '10620cd1fe3b07d0a0c067934c1496593e75994a26d6441b835635d98fda90db'
  return pbkdf2.pbkdf2_hex(data, salt.lower(), 2048, 32)

window.PYpbkdf2 = PYpbkdf2


def PYfetchKey(email):
  keys = gpg.search_keys("<%s>" % email)
  if keys.fingerprints == []:
    return None
  else:
    imported = gpg.recv_keys('pgp.mit.edu',keys.fingerprints[0])
    return imported.fingerprints[0]

window.PYfetchKey = PYfetchKey


def PYimportKey(key):
  return gpg.import_keys(key)

window.PYimportKey = PYimportKey


def PYlistKeys():
  return gpg.list_keys()

window.PYlistKeys = PYlistKeys


def PYencryptAndSign(data, recipients, signer, passphrase):
  #Because of the way Tide passes stuff around, recipients
  #doesn't seem to arrive as a legitimate Python list, but
  #it is an iterator. gpg.encrypt expects a nice list, so:
  rlist = [fp for fp in recipients]
  #TODO:implement trust levels, think about how/when accounts should sign each other's keys
  data = gpg.encrypt(data, rlist, sign=signer, passphrase=passphrase, always_trust=True)
  window.console.log(data)
  return data.data

window.PYencryptAndSign = PYencryptAndSign


def PYdecryptAndVerify(data, passphrase, sender_id):
  #TODO:implement WoT validation
  decrypted_data =  gpg.decrypt(data, passphrase=passphrase, always_trust=True)
  window.console.log(decrypted_data)
  #if decrypted_data.fingerprint == sender_id:
  if decrypted_data.data:
    return decrypted_data.data
  else:
    return "Parley Exception: Unable to decrypt this message with information given."

window.PYdecryptAndVerify = PYdecryptAndVerify


def PYchangePass(newPass):
  oldPass = window.Parley.currentUser.attributes.passwords.local
  private_key = gpg.list_keys(True)
  keyid = private_key[0]['fingerprint']
  return gpg.change_pass(keyid,oldPass,newPass)

window.PYchangePass = PYchangePass


def PYrevokeKey():
  private_key = gpg.list_keys(True)
  keyid = private_key[0]['fingerprint']
  revocation  = gpg.gen_revoke(keyid,window.Parley.currentUser.attributes.passwords.local)
  if revocation[0]:
    revoked = gpg.import_keys(revocation[0])
    if revoked.count:
      gpg.send_keys('pgp.mit.edu',keyid)
      return revocation
    else:
      return False
  else:
    return False

window.PYrevokeKey = PYrevokeKey

def PYchangeName(newName):
  oldEmail = window.Parley.currentUser.attributes.email
  private_key = gpg.list_keys(True)
  fp = private_key[0]['fingerprint']
  return gpg.add_uid(fp,newName,oldEmail,'Generated by Parley',window.Parley.currentUser.attributes.passwords.local)

window.PYchangeName = PYchangeName
